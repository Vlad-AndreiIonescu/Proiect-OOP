#pragma warning(push)
#pragma warning(disable : 4996)
#include<iostream>
#include<ctype.h>
#include<string>
using namespace std;

class mesajExceptie
{
    string mesajDeExceptie;
public:
    mesajExceptie(string mesajDeExceptie)
    {
        this->mesajDeExceptie = mesajDeExceptie;

    }
    string getMesajDeExceptie()
    {
        return this->mesajDeExceptie;
    }
};
class Creare {
    bool isCorrect;
    string cccc;
    string tableName;
    string* columnName;
    string* tip;
    string* dimensiune;
    string* valoareImplicita;
    int nrIntroduceri;
    int nrTabeleCreate;

public:
    Creare()
    {
        this->isCorrect = false;
        this->tableName = "";
        this->columnName = NULL;
        this->tip = NULL;
        this->dimensiune = NULL;
        this->valoareImplicita = NULL;
        this->nrIntroduceri = 0;
        nrTabeleCreate++;
    }
    Creare(bool isCorrect, string tableName, string* columnName, string* tip, string* dimensiune, string* valoareImplicita, int nrIntroduceri) {

        this->isCorrect = isCorrect;
        this->tableName = tableName;
        this->nrIntroduceri = nrIntroduceri;
        this->columnName = new string[this->nrIntroduceri];
        for (int i = 0; i < nrIntroduceri; i++) {
            this->columnName[i] = columnName[i];
        }
        this->tip = new string[this->nrIntroduceri];
        for (int i = 0; i < nrIntroduceri; i++) {
            this->tip[i] = tip[i];
        }
        this->dimensiune = new string[this->nrIntroduceri];
        for (int i = 0; i < nrIntroduceri; i++) {
            this->dimensiune[i] = dimensiune[i];
        }
        this->valoareImplicita = new string[this->nrIntroduceri];
        for (int i = 0; i < nrIntroduceri; i++) {
            this->valoareImplicita = valoareImplicita;
        }
        nrTabeleCreate++;
    }
    ~Creare() {

        if (columnName != NULL)
            delete[] columnName;

        if (tip != NULL)
            delete[] tip;

        if (dimensiune != NULL)
            delete[] dimensiune;
        if (valoareImplicita != NULL)
            delete[] valoareImplicita;

    }
    Creare(const Creare& c) {
        this->isCorrect = c.isCorrect;
        this->tableName = c.tableName;
        this->nrIntroduceri = c.nrIntroduceri;
        if (this->columnName != NULL)
            delete[] columnName;
        this->columnName = new string[c.nrIntroduceri];
        for (int i = 0; i < this->nrIntroduceri; i++) {
            this->columnName[i] = c.columnName[i];
        }
        if (this->tip != NULL) {
            delete[] this->tip;
        }
        this->tip = new string[nrIntroduceri];
        for (int i = 0; i < this->nrIntroduceri; i++) {
            this->tip[i] = c.tip[i];
        }
        if (this->dimensiune != NULL) {
            delete[] this->dimensiune;
        }
        this->dimensiune = new string[nrIntroduceri];
        for (int i = 0; i < nrIntroduceri; i++) {
            this->dimensiune[i] = c.dimensiune[i];
        }
        if (this->valoareImplicita != NULL) {
            delete[] this->valoareImplicita;
        }
        this->valoareImplicita = new string[nrIntroduceri];
        for (int i = 0; i < nrIntroduceri; i++) {
            this->valoareImplicita[i] = c.valoareImplicita[i];
        }

        nrTabeleCreate++;
    }
    Creare& operator=(const Creare& c) {
        this->isCorrect = c.isCorrect;
        this->tableName = c.tableName;
        this->nrIntroduceri = c.nrIntroduceri;
        if (this->columnName != NULL)
            delete[] columnName;
        this->columnName = new string[c.nrIntroduceri];
        for (int i = 0; i < this->nrIntroduceri; i++) {
            this->columnName[i] = c.columnName[i];
        }
        if (this->tip != NULL) {
            delete[] this->tip;
        }
        this->tip = new string[nrIntroduceri];
        for (int i = 0; i < this->nrIntroduceri; i++) {
            this->tip[i] = c.tip[i];
        }
        if (this->dimensiune != NULL) {
            delete[] this->dimensiune;
        }
        this->dimensiune = new string[nrIntroduceri];
        for (int i = 0; i < nrIntroduceri; i++) {
            this->dimensiune[i] = c.dimensiune[i];
        }
        if (this->valoareImplicita != NULL) {
            delete[] this->valoareImplicita;
        }
        this->valoareImplicita = new string[nrIntroduceri];
        for (int i = 0; i < nrIntroduceri; i++) {
            this->valoareImplicita[i] = c.valoareImplicita[i];
        }

        nrTabeleCreate++;
        return *this;
    }
    void setIsCorrect(bool isCorrect) {
        this->isCorrect = isCorrect;
    }

    void settableName(string tableName) {
        this->tableName = tableName;
    }
    void setcolumnName(string* columnName, int nrIntroduceri) {
        if (columnName != NULL && nrIntroduceri > 0) {
            this->nrIntroduceri = nrIntroduceri;
            if (this->columnName != NULL) {
                delete[] this->columnName;
            }
            this->columnName = new string[nrIntroduceri];
            for (int i = 0; i < nrIntroduceri; i++) {
                this->columnName[i] = columnName[i];
            }

        }
    }
    void setTip(string* tip, int nrIntroduceri) {
        if (tip != NULL && nrIntroduceri > 0) {
            this->nrIntroduceri = nrIntroduceri;
            if (this->tip != NULL) {
                delete[] this->tip;
            }
            this->tip = new string[nrIntroduceri];
            for (int i = 0; i < nrIntroduceri; i++) {
                this->tip[i] = tip[i];
            }
        }

    }
    void setdimensiune(string* dimensiune, int nrIntroduceri) {
        if (dimensiune != NULL && nrIntroduceri > 0) {
            this->nrIntroduceri = nrIntroduceri;
            if (this->dimensiune != NULL) {
                delete[] this->dimensiune;
            }
            this->dimensiune = new string[nrIntroduceri];
            for (int i = 0; i < nrIntroduceri; i++) {
                this->dimensiune[i] = dimensiune[i];
            }
        }
    }
    void setvaloareImplicita(string* valoareImplicita, int nrIntroduceri) {
        if (valoareImplicita != NULL && nrIntroduceri > 0) {
            this->nrIntroduceri = nrIntroduceri;
            if (this->valoareImplicita != NULL) {
                delete[] this->valoareImplicita;
            }
            this->valoareImplicita = new string[nrIntroduceri];
            for (int i = 0; i < nrIntroduceri; i++) {
                this->valoareImplicita[i] = valoareImplicita[i];
            }
        }
    }
    bool getIsCorrect() {
        return this->isCorrect;
    }
    int getNrIntroduceri() {
        return this->nrIntroduceri;
    }
    string gettableName() {
        return this->tableName;
    }
    string* getcolumnName() {
        if (this->columnName != NULL) {
            return this->columnName;
        }
        return NULL;
    }
    string getcolumnName(int index) {
        if (this->columnName != NULL && index < this->nrIntroduceri && index >= 0) {
            return columnName[index];
        }
        return NULL;
    }
    string* getTip() {
        if (this->tip != NULL) {
            return this->tip;
        }
        return NULL;
    }
    string getTip(int index) {
        if (this->tip != NULL && index < this->nrIntroduceri && index >= 0) {
            return tip[index];
        }
    }  string* getDimensiune() {
        if (this->dimensiune != NULL) {
            return this->dimensiune;
        }
        return NULL;
    }
    string getDimensiune(int index) {
        if (this->dimensiune != NULL && index < this->nrIntroduceri && index >= 0) {
            return dimensiune[index];
        }
        return NULL;
    }
    string* getValoareImplicita() {
        if (this->valoareImplicita != NULL) {
            return this->valoareImplicita;
        }
        return NULL;
    }
    string getValoareImplicita(int index) {
        if (this->valoareImplicita != NULL && index < this->nrIntroduceri && index >= 0) {
            return valoareImplicita[index];
        }
        return NULL;
    }

    void verifyCreateTable(char* comanda) {

        char* words;
        isCorrect = false;
        words = new char[strlen(comanda) + 1];
        strcpy(words, comanda);
        string vCT(words, words + 12);
        char* parenthesis;


        if (vCT == "CREATE TABEL") {
            int nr = 13;
            while (words[nr] != ' ' && words[nr] != '(')
                nr++;
            string numeTabel(words + 13, words + nr);
            this->tableName = numeTabel;
            if (words[nr + 2] == words[nr + 1] && words[nr + 1] == '(') {
                int count = nr;
                int countTip, countDimensiune, countValoareImplicita;
                for (int i = 0; i < nrIntroduceri; i++) {
                    while (words[count] != ',')
                        count++;
                    string columnName(words + nr, words + count);
                    this->columnName[i] = columnName;
                    if (words[count + 1] != ',') {
                        throw mesajExceptie("Comanda executata este gresita");
                    }
                    countTip = count;
                    while (words[countTip] != ',')
                        countTip++;
                    string tip(words + count, words + countTip);
                    this->tip[i] = tip;
                    if (words[countTip + 1] != ',') {
                        throw mesajExceptie("Comanda executata este gresita");
                    }

                    countDimensiune = countTip;
                    while (words[countDimensiune] != ',')
                        countDimensiune++;
                    string dimensiune(words + count, words + countDimensiune);
                    this->dimensiune[i] = dimensiune;
                    if (words[countDimensiune + 1] != ',') {
                        throw mesajExceptie("Comanda executata este gresita");
                    }

                    countValoareImplicita = countDimensiune;
                    while (words[countValoareImplicita] != ',')
                        countValoareImplicita++;
                    string valoareImplicita(words + count, words + countValoareImplicita);
                    this->valoareImplicita[i] = valoareImplicita;
                    if (words[countValoareImplicita + 1] != ')') {
                        throw mesajExceptie("Comanda executata este gresita");
                    }
                }





            }
            else  throw mesajExceptie("Comanda executata este gresita");


        }
    }
    friend ostream& operator<<(ostream&, Creare);
};
ostream& operator<<(ostream& out, Creare c) {
    out << "Comanda introdusa este :" << c.getIsCorrect() << endl;
    out << "Se va implementa tabela " << c.gettableName() << " cu coloanele:";
    for (int i = 0; i < c.getNrIntroduceri(); i++) {
        out << c.getcolumnName()[i] << " de tip " << c.getTip()[i] << ", de dimensiune" << c.getDimensiune()[i]
            << " si valoare implicita " << c.getValoareImplicita()[i];
        out << endl;
    }
    out << "Numarul de introduceri este de :" << c.getNrIntroduceri();
    out << endl;
    return out;

}

class Delete {
    string columnName;
    string tableName;
    bool isCorrect;
    char* value;

public:
    Delete() {
        columnName = "Necunoscut";
        tableName = "Necunoscut";
        isCorrect = false;
        value = nullptr;
    }
    Delete(bool isCorrect, string tableName, string columnName, char* value) {
        this->columnName = columnName;
        this->tableName = tableName;
        this->isCorrect = isCorrect;
        for (int i = 0; i < strlen(value); i++)
            this->value[i] = value[i];
    }
    Delete(const Delete& d) {
        this->columnName = d.columnName;
        this->tableName = d.tableName;
        this->isCorrect = d.isCorrect;
        if (this->value != NULL) {
            delete[] this->value;
        }
        this->value = new char[strlen(d.value)];
        for (int i = 0; i < strlen(d.value); i++)
            this->value[i] = d.value[i];
    }
    Delete& operator=(const Delete& d) {
        this->columnName = d.columnName;
        this->tableName = d.tableName;
        this->isCorrect = d.isCorrect;
        for (int i = 0; i < strlen(d.value); i++)
            this->value[i] = d.value[i];
        return *this;
    }
    void setIsCorrect(bool isCorrect) {
        this->isCorrect = isCorrect;
    }
    void settableName(string tableName) {
        this->tableName = tableName;

    }
    void setcolumnName(string columnName) {
        this->columnName = columnName;

    }
    bool getisCorrect() {
        return this->isCorrect;
    }

    string gettableName() {
        return this->tableName;

    }
    string getcolumnName() {
        return this->columnName;

    }
    char* getvalue() {
        return this->value;
    }
    void verifyDelete(char* comanda) {

        isCorrect = false;
        char*words;
        words = new char[strlen(comanda)];
        strcpy(words, comanda);

        string vDel(words, words + 11);

        if (isspace(words[11])) {

            int i = 12;
            while (!isspace(words[i])) {
                i++;
            }
            string tableName(words + 12, words + i);
            this->tableName = tableName;
            if (vDel == "DELETE FROM" && i != 12) {//de aici incoace intra in delete
                int j;
                j = i + 1;

                while (!isspace(words[j]))
                    j++;

                if (words[strlen(words - 1)] == ';') {
                    string where(words[i + 1], words[j]);
                    if (where == "WHERE") {
                        int k;
                        k = j + 1;
                        while (words[k] != '=' && words != NULL)
                            k++;
                        string columnName(words + j, words + k);
                        this->columnName = columnName;

                        if (words[k] == '=') {
                            int n = k + 2;
                            while (words[n] != ';' && words[n] != NULL)
                                n++;
                            string value(words[k + 2], words[n]);
                            strcpy(this->value, value.c_str());

                            int flag = 1;
                            for (int i = 0; i < value.length() && flag == 0; i++) {
                                if (!(isdigit(value[i]) || isalpha(value[i])) || value[i] != '_')
                                    flag = 0;
                            }
                            if (flag == 1)
                                isCorrect = 1;
                        }
                    }
                }

            }
        }
        if (isCorrect == false)  throw mesajExceptie("EROARE!Comanda nu poate executata.");
        else throw mesajExceptie("Comanda a fost executata");
    }
    friend ostream& operator<<(ostream&, Delete);
};
ostream& operator<<(ostream& out, Delete d) {
    out << "Comanda introdusa este:" << d.getisCorrect() << endl;
    out << "Modificarile sunt facute pentru coloana " << d.getcolumnName() << " din tabela " << d.gettableName() << endl;
    out << "Valorile introduse sunt : " << d.getvalue() << endl;
    return out;
}
class Display
{
    bool isCorrect;
    char* tableName;

public:
    Display() {
        this->isCorrect = false;
        this->tableName = NULL;
    }

    Display(bool isCorrect, const char* tableName) {
        this->isCorrect = isCorrect;
        this->tableName = new char[strlen(tableName) + 1];
        strcpy(this->tableName, tableName);
    }
    Display(const Display& d) {
        this->isCorrect = d.isCorrect;
        if (tableName != NULL)
            delete[]  tableName;
        this->tableName = new char[strlen(d.tableName) + 1];
        strcpy(this->tableName, d.tableName);
    }

    ~Display() {
        if (this->tableName) {
            delete[] tableName;
        }
        tableName = NULL;
    }
    Display& operator=(const Display& d) {
        this->isCorrect - d.isCorrect;
        if (this->tableName) {
            delete[]this->tableName;
        }
        this->tableName = new char[strlen(d.tableName) + 1];
        strcpy(this->tableName, d.tableName);
        return *this;
    }
    //getteri si setteri
    void setIsCorrect(bool isCorrect) {
        this->isCorrect = isCorrect;
    }

    void setTableName(char* tableName) {
        if (tableName) {
            if (this->tableName) {
                delete[]this->tableName;
            }
            this->tableName = new char[strlen(tableName) + 1];
            strcpy(this->tableName, tableName);
        }
    }

    bool getIsCorrect() {
        return this->isCorrect;
    }
    char* getTableName() {
        return this->tableName;
    }
    

    void verifyDisplay(char* c) {
        this->isCorrect = false;
        int nr = 0;
        int copie = 0;
        char* verify;
        verify = new char[strlen(c) + 1];
        strcpy(verify, c);

        string s(verify, verify + 13);
        strcpy(verify - 1, verify + 13);
        strrev(verify);
        strcpy(verify, verify + 1);
        strrev(verify);

        if (this->tableName) {
            delete[]this->tableName;
        }
        this->tableName = new char[strlen(verify) + 1];
        strcpy(this->tableName, verify);
        //se retine numele tabelei
        if (s == "DISPLAY TABLE") {

            if (c[strlen(c) - 1] == ';') {
                this->isCorrect = true;
            }
        }
        //verify daca comanda e scrisa corect
        if (isCorrect == false) {
            throw mesajExceptie("Comanda introdusa nu e buna");
        }
        else {
            cout << "Comanda a fost executata" << endl;
        }
    }

    friend ostream& operator<< (ostream&, Display);
};
ostream& operator<< (ostream& out, Display d) {
    out << "Comanda introdusa este :" << d.getIsCorrect() << endl;
    out << "Numele tabelei este: ";
    for (int i = 0; i < strlen(d.tableName); i++) {
        out << d.getTableName()[i];
    }
    out << endl;
    return out;
}
class Drop {

    char* tableName;
    bool isCorrect;
    

public:
    Drop() {
        this->tableName = NULL;
        this->isCorrect = false;
    }

    Drop(bool isCorrect, const char* tableName) {
        this->tableName = new char[strlen(tableName) + 1];
        strcpy(this->tableName, tableName);
        this->isCorrect = isCorrect;
    }
    Drop(const Drop& d) {
        if (tableName != NULL)
            delete[] tableName;

        this->tableName = new char[strlen(d.tableName) + 1];
        strcpy(this->tableName, d.tableName);
        this->isCorrect = d.isCorrect;
    }



    ~Drop() {
        tableName = NULL;
        if (this->tableName) {
            delete[]tableName;
        }

    }
    Drop& operator=(const Drop& d) {
        this->isCorrect - d.isCorrect;
        if (this->tableName) {
            delete[]this->tableName;
        }
        this->tableName = new char[strlen(d.tableName) + 1];
        strcpy(this->tableName, d.tableName);
        return *this;
    }
    void setIsCorrect(bool isCorrect) {
        this->isCorrect = isCorrect;
    }

    void settableName(char* tableName) {
        if (tableName) {
            if (this->tableName) {
                delete[]this->tableName;
            }
            this->tableName = new char[strlen(tableName) + 1];
            strcpy(this->tableName, tableName);
        }
    }
    bool getIsCorrect() {
        return this->isCorrect;
    }

    char* gettableName() {
        return this->tableName;
    }
    void verifyDrop(char* c) {
        this->isCorrect = false;
        int nr = 0;
        int copy = 0;
        char* verify;
        verify = new char[strlen(c) + 1];
        strcpy(verify, c);
        for (int i = 0; i < strlen(c); i++)
        {
            if (isspace(c[i]))
            {
                nr++;
                copy = i;
            }
        }
        //retine DROP TABLE
        string s(verify, verify + 10);
        strcpy(verify, verify + 11);
        strrev(verify);
        strcpy(verify, verify + 1);
        strrev(verify);
        //verify retine totul dupa drop table

        if (this->tableName) {
            delete[]this->tableName;
        }
        this->tableName = new char[strlen(verify) + 1];
        strcpy(this->tableName, verify);
        //se retine numele tabelei
        if (s == "DROP TABLE") {
            if (isalpha(c[copy + 2]) && c[strlen(c) - 1] == ';') {
                this->isCorrect = true;
            }
        }
        //verifica daca comanda e scrisa corect
        if (isCorrect == false) {
            throw mesajExceptie("Comanda introdusa nu e buna");
        }
        else {
            cout << "Comanda a fost executata" << endl;
        }
    }
    friend ostream& operator<< (ostream&, Drop);
};
ostream& operator<<(ostream& out, Drop d) {
    out << "Comanda introdusa este :" << d.getIsCorrect() << endl;
    out << "Modificarile sunt facute pentru tabela :";
    for (int i = 0; i < strlen(d.tableName); i++) {
        out << d.gettableName()[i];
    }
    out << endl;
    return out;
}
class Select {
    bool isCorrect;
    string columnName;
    string  tableName;
    string* stringColumnsName;
    int nrColumns;
    string valoareImplicita;

public:
    Select() {
        isCorrect = false;
        columnName = "Necunoscut";
        tableName = "Necunoscut";
        stringColumnsName = nullptr;
        nrColumns = 0;
        valoareImplicita = "Necunoscut";
    }
    Select(bool isCorrect, string stringColumnsName, int nrColumns, string columnName, string  tableName, string valoareImplicita) {
        this->isCorrect = isCorrect;
        this->columnName = columnName;
        this->tableName = tableName;
        for (int i = 0; i < nrColumns; i++)
            this->stringColumnsName[i] = stringColumnsName[i];
        this->nrColumns = nrColumns;
        this->valoareImplicita = valoareImplicita;
    }
    Select(const Select& s) {

        this->isCorrect = s.isCorrect;
        this->columnName = s.columnName;
        this->tableName = s.tableName;
        if (stringColumnsName != NULL)
            delete[] stringColumnsName;
        for (int i = 0; i < nrColumns; i++)
            this->stringColumnsName[i] = s.stringColumnsName[i];
        this->nrColumns = s.nrColumns;
        this->valoareImplicita = s.valoareImplicita;
    }

    Select& operator= (const Select& s) {
        this->isCorrect = s.isCorrect;
        this->columnName = s.columnName;
        this->tableName = s.tableName;
        if (this->stringColumnsName != NULL) {
            delete[] this->stringColumnsName;
        }
        for (int i = 0; i < nrColumns; i++)
            this->stringColumnsName[i] = s.stringColumnsName[i];
        this->nrColumns = s.nrColumns;
        this->valoareImplicita = s.valoareImplicita;
        return *this;

    }
    bool getIsCorrect() {
        return this->isCorrect;
    }
    string* getstringColumnsName() {
        return this->stringColumnsName;

    }
    int getnrColumns() {
        return this->nrColumns;
    }
    string getColumnName() {
        return this->columnName;
    }
    string getTableName() {
        return this->tableName;
    }
    string getValoareImplicita() {
        return this->valoareImplicita;
    }
    void setisCorrect(bool isCorrect) {
        this->isCorrect = isCorrect;
    }
    void setstringColumnsName(string* stringColumnsName, int nrColumns) {
        this->nrColumns = nrColumns;
        if (this->stringColumnsName != NULL)
            delete[] this->stringColumnsName;
        if (stringColumnsName != NULL)
            this->stringColumnsName = new string[nrColumns];
        for (int i = 0; i < nrColumns; i++)
            this->stringColumnsName[i] = stringColumnsName[i];

    }
    void setnrColumns(int nrColumns) {

        this->nrColumns = nrColumns;
    }
    void setColumnName(string columnName) {

        this->columnName = columnName;
    }
    void setTableName(string  tableName) {
        this->tableName = tableName;

    }
    void setValoareImplicita(string valoare) {
        this->valoareImplicita = valoare;
    }
    void verifySelect(char* c)
    {
        int pozFrom = 0;
        char* words;
        int nr = 1;
        words = new char[strlen(c) + 1];
        strcpy(words, c);

        string vSelect(words, words + 6);

        char* stringParanthesis;
        stringParanthesis = new char[strlen(words) + 1];
        strcpy(stringParanthesis, words + 7);

        if (vSelect == "SELECT" && words[strlen(words) - 1] == ';')
        {
            if ((words[strlen("SELECT")] == '(') || (words[strlen("SELECT") + 1] == '('))
            {
                if (isspace(words[6]))
                {
                    int i = 7;
                    int k = i;
                    while (words[k] != ')')
                        k++;

                    string paranteze(words + 7, words + k + 1);
                    const char* paranteze1 = paranteze.c_str();
                    strcpy(stringParanthesis, paranteze1);

                    this->stringColumnsName = new string[100];

                    int l = 0;
                    if (stringParanthesis[0] == '(' && stringParanthesis[strlen(stringParanthesis) - 1] == ')')
                    {
                        strcpy(stringParanthesis, stringParanthesis + 1);
                        strrev(stringParanthesis);
                        strcpy(stringParanthesis, stringParanthesis + 1);
                        strrev(stringParanthesis);


                        int nrComma = 0;
                        for (int i = 0; i < strlen(stringParanthesis) + 1; i++)
                        {
                            if (stringParanthesis[i] == ',')
                            {
                                nrComma++;
                            }
                        }
                        pozFrom = k + 2;
                        int k = 0;
                        int n = strlen(stringParanthesis);
                        strcat(stringParanthesis, ",");

                        if (stringParanthesis[0] != ',') {
                            int ci = 0;
                            int nrwords = 0;
                            int i = 0;
                            while (i < strlen(stringParanthesis)) {
                                if (stringParanthesis[i] == ',') {
                                    nrwords++;
                                    string n(stringParanthesis + ci, stringParanthesis + i);
                                    this->stringColumnsName[nrwords] = n;
                                    i = i + 2;
                                    ci = i;
                                }
                                else i++;

                            }
                            if (nrwords == nrComma + 1)
                            {
                                nr = 0;
                            }
                        }
                    }
                }

            }
        }
        else {
            string s(words, words + 10);
            //verificare daca nu exista parantezele si este de forma "SELECT ALL"
            if (s == "SELECT ALL") {
                pozFrom = 11;
                cout << words[11] << endl;
                nr = 0;
            }
        }
        string from(words + pozFrom, words + pozFrom + 4);
        //retine cuvantul "FROM"

        if (from == "FROM" && nr == 0) {
            this->isCorrect = false;
            strcpy(words, words + pozFrom + 5);
            //words retine tot ce e dupa ALL FROM

            int n = 0;
            while (words[n] != ' ' && words[n] != NULL && words[n] != ';')
                n++;
            if (n != 0) {
                string  tableName(words, words + n);
                this->tableName = tableName;
                //retine nume tabela
            }
            if (words[n] == ';' || words[n + 1] == ';') {
                isCorrect = true;
            }//poate fi adev prop si daca nu mai exista partea cu WHERE, insa la sf trb sa aiba";"
            else if (words[n + 1] == 'W') {
                string where(words + n + 1, words + n + 6);
                //retine cuv "WHERE"
                if (where == "WHERE")
                {
                    n = n + 7;
                    int i = n + 1;
                    while (words[i] != ' ')
                        i++;
                    if (n = 1 < i)
                    {
                        string columnName(words + n, words + i);
                        this->columnName = columnName;
                        //retine nume_coloana
                    }
                    else nr++;
                    if (words[i + 1] == '=')
                        i = i + 1;
                    else nr++;
                    //verifica daca exista =in clauza WHERE
                    int ultimul = i + 2;

                    if (strlen(words) - 2 != ultimul) {
                        string valoare(words + ultimul, ultimul + strlen(words) - 1);
                        this->valoareImplicita = valoare;
                    }
                    else nr++;
                    //retine valoare
                    if (nr == 0)//verifica daca exista vreo eroare la introducere
                        this->isCorrect = true;
                }
            }
        }
        if (this->isCorrect == true) {
            cout << "Comanda introdusa a fost executata" << endl;
        }
        else throw mesajExceptie("Comanda introdusa nu este buna");
    }
};    
class Update
{

    bool isCorrect;
    char* tableName;
    string* columnName;
    string* valoareIntrodusa;

public:
    Update()
    {
        columnName = NULL;
        tableName = NULL;
        valoareIntrodusa = NULL;
        this->isCorrect = false;
    }
    Update(bool isCorrect, int nrColoane, string* columnName, const char* tableName, string* valoareIntrodusa)
    {
        this->columnName = new string[2];
        for (int i = 0; i < 2; i++) {
            this->columnName[i] = columnName[i];
        }
        this->tableName = new char[strlen(tableName) + 1];
        strcpy(this->tableName, tableName);
        this->valoareIntrodusa = new string[2];
        for (int i = 0; i < 2; i++) {
            this->valoareIntrodusa[i] = valoareIntrodusa[i];
        }
        this->isCorrect = isCorrect;
    }
    Update(const Update& u)
    {
        this->columnName = new string[2];
        for (int i = 0; i < 2; i++) {
            this->columnName[i] = u.columnName[i];
        }
        this->tableName = new char[strlen(u.tableName) + 1];
        strcpy(this->tableName, u.tableName);
        this->valoareIntrodusa = u.valoareIntrodusa;
        for (int i = 0; i < 2; i++) {
            this->valoareIntrodusa[i] = u.valoareIntrodusa[i];
        }
        this->isCorrect = u.isCorrect;
    }
    ~Update()
    {
        if (this->tableName) {
            delete[]this->tableName;
        }
        this->tableName = NULL;

        if (this->columnName) {
            delete[]this->columnName;
        }
        this->columnName = NULL;

        if (this->valoareIntrodusa) {
            delete[]this->valoareIntrodusa;
        }
        this->valoareIntrodusa = NULL;
    }

    Update& operator= (const Update& u)
    {

        if (this->tableName)
        {
            delete[] this->tableName;
        }
        this->tableName = new char[strlen(u.tableName) + 1];
        strcpy(this->tableName, u.tableName);
        if (this->columnName) {
            delete[]this->columnName;
        }

        this->columnName = new string[2];
        for (int i = 0; i < 2; i++) {
            this->columnName[i] = u.columnName[i];

            if (this->valoareIntrodusa) {
                delete[]this->valoareIntrodusa;
            }
            this->valoareIntrodusa = new string[2];
            for (int i = 0; i < 2; i++) {
                this->valoareIntrodusa[i] = u.valoareIntrodusa[i];
            }

            this->isCorrect = u.isCorrect;
        }
        return *this;


    }
    void setIsCorrect(bool isCorrect) {
        this->isCorrect = isCorrect;
    }

    void settableName(char* tableName) {
        if (tableName) {
            if (this->tableName)
            {
                delete[]this->tableName;
            }
            this->tableName - new char[strlen(tableName) + 1];
            strcpy(this->tableName, tableName);

        }
    }

    void setValoareIntrodusa(string* valoareIntrodusa) {
        if (valoareIntrodusa) {
            if (this->valoareIntrodusa) {
                delete[]this->valoareIntrodusa;
            }
            this->valoareIntrodusa = new string[2];
            for (int i = 0; i < 2; i++) {
                this->valoareIntrodusa[i] = valoareIntrodusa[i];
            }
        }
    }
    void setcolumnName(string* columnName) {
        if (columnName) {
            if (this->columnName) {
                delete[]this->columnName;
            }
            this->columnName = new string[2];
            for (int i = 0; i < 2; i++) {
                this->columnName[i] = columnName[i];
            }
        }
    }
    bool getIsCorrect() {
        return this->isCorrect;
    }

    char* gettableName() {
        return this->tableName;
    }
    string* getValoareIntrodusa()
    {
        return this->valoareIntrodusa;
    }
    string getValoareIntrodusa(int index) {
        if (index == 0 || index == 1) {
            return this->valoareIntrodusa[index];

        }
    }


    string* getcolumnName() {
        return this->columnName;
    }
    string getcolumnName(int index) {
        if (index == 0 || index == 1) {
            return this->columnName[index];
        }
    }

    void verifyUpdate(char* c) {
        isCorrect = false;
        char* words;
        words = new char[strlen(c)];
        strcpy(words, c);
        string s(words, words + 6);
        //retine UPDATE
        if (isspace(words[6]))
        {
            int i = 7;
            while (!isspace(words[i]))
                i++;
            string tableName(words + 7, words + i);
            if (this->tableName) {
                delete[]this->tableName;
            }
            this->tableName = new char[tableName.length() + 1];
            strcpy(this->tableName, tableName.c_str());
            //retine nume tabela

            if (s == "UPDATE") {
                if (i != 7)
                {
                    int j;
                    j = i + 1;
                    while (!isspace(words[j]))
                        j++;
                    string set(words + i + 1, words + j);
                    //retine SET
                    if (set == "SET") {
                        int k = j + 1;
                        if (words[strlen(words) - 1] == ';')
                        {
                            while (words[k] != '=' && words[k] != ' ')
                                k++;
                            string columnName1(words + j + 1, words + k);//retine numele primei coloane
                            if (this->columnName) {
                                delete[]this->columnName;
                            }
                            this->columnName = new string[2];//va retine numele celor 2 clase
                            this->columnName[0] = columnName1;

                            if (words[k + 1] == '=') {
                                int n = k + 3;
                                while (!isspace(words[n]))
                                    n++;
                                string valoare1(words + k + 3, words + n);
                                //retine valoarea 1
                                if (this->valoareIntrodusa) {
                                    delete[]this->valoareIntrodusa;
                                }
                                this->valoareIntrodusa = new string[2];
                                this->valoareIntrodusa[0] = valoare1;
                                string where(words + n + 1, words + n + 6);
                                //retine cuvantul WHERE
                                if (where == "WHERE")
                                {
                                    int poz = n + 7;
                                    while (words[poz] != '=' && words[poz] != ' ')
                                        poz = poz + 1;
                                    string columnName2(words + n + 7, words + poz);
                                    //retine a 2 a coloana
                                    this->columnName[1] = columnName2;
                                    if (words[poz + 1] == '==') {
                                        poz = poz + 3;
                                        int sf = poz;
                                        while (words[sf] != NULL)
                                            sf++;
                                        string valoare2(words + poz, words + sf);
                                        //retine a 2 a valoare
                                        this->valoareIntrodusa[1] = valoare2;
                                        isCorrect = true;



                                    }

                                }

                            }

                        }
                    }
                }
            }
        }
        if (isCorrect == false) {
            throw mesajExceptie("Comanda introdusa nu este valida");
        }
        else {
            cout << "Comanda introdusa a fost executata" << endl;

        }
    }
    friend ostream& operator<<(ostream&, Update);
};
ostream& operator<<(ostream& out, Update u) {
    out << "Comanda introdusa este:" << u.getIsCorrect() << endl;
    out << "Modificarile sunt facute pentru tabela " << u.gettableName() << endl;
    out << "Valorile introduse sunt : ";
    for (int j = 0; j < sizeof(u.valoareIntrodusa); j++) {
        out << u.getValoareIntrodusa()[j] << " ";
    }
    return out;
}
class Insert
{
    bool isCorrect;
    char* tableName;
    string* valoareIntrodusa;
    int nrValues;


public:
    Insert() {
        this->isCorrect = false;
        this->tableName = NULL;
        this->valoareIntrodusa = NULL;
        this->nrValues = 0;
    }

    Insert(bool isCorrect, const char* tableName, string* valoareIntrodusa, int nrValues)
    {
        this->isCorrect = isCorrect;
        this->tableName = new char[strlen(tableName) + 1];
        strcpy(this->tableName, tableName);
        this->nrValues = nrValues;
        this->valoareIntrodusa = new string[this->nrValues];
        for (int i = 0; i < this->nrValues; i++) {
            this->valoareIntrodusa[i] = valoareIntrodusa[i];
        }
    }
    Insert(const Insert& ins) {
        this->isCorrect = ins.isCorrect;
        this->tableName = new char[strlen(ins.tableName) + 1];
        strcpy(this->tableName, ins.tableName);
        this->nrValues = ins.nrValues;
        this->valoareIntrodusa = new string[this->nrValues];
        for (int i = 0; i < this->nrValues; i++)
        {
            this->valoareIntrodusa[i] = ins.valoareIntrodusa[i];
        }
    }

    ~Insert() {
        if (this->tableName) {
            delete[]tableName;
        }
        tableName = NULL;
        if (this->valoareIntrodusa)
        {
            delete[]this->valoareIntrodusa;
        }
        this->valoareIntrodusa = NULL;
    }
    Insert& operator=(const Insert& ins) {
        this->isCorrect = ins.isCorrect;
        if (this->tableName) {
            delete[]this->tableName;
        }
        this->tableName = new char[strlen(ins.tableName) + 1];
        strcpy(this->tableName, ins.tableName);
        this->nrValues = ins.nrValues;
        if (this->valoareIntrodusa) {
            delete[]this->valoareIntrodusa;
        }
        this->valoareIntrodusa = new string[this->nrValues];
        for (int i = 0; i < this->nrValues; i++) {
            this->valoareIntrodusa[i] = ins.valoareIntrodusa[i];
        }
        return *this;
    }
    //operatorul explicit
    explicit operator float() {
        return this->nrValues;
    }

    //operator de negare
    bool operator!() {
        this->isCorrect = !(this->isCorrect);
        return this->isCorrect;
    }

    //getteri si setteri
    int getnrValues() {
        return this->nrValues;
    }

    bool getIsCorrect() {
        return this->isCorrect;
    }
    char* gettableName() {
        return this->tableName;
    }

    string* getValoareIntrodusa() {
        return this->valoareIntrodusa;
    }
    string getValoareIntrodusa(int i) {
        if (i >= 0 && i < this->nrValues) {
            return this->valoareIntrodusa[i];
        }
    }
    void setIsCorrect(bool isCorrect) {
        this->isCorrect = isCorrect;
    }
    void settableName(char* tableName) {
        if (tableName) {
            if (this->tableName) {
                delete[]this->tableName;
            }
            this->tableName = new char[strlen(tableName) + 1];
            strcpy(this->tableName, tableName);
        }

    }

    void setValoareIntrodusa(string* valoareIntrodusa, int nrValues)
    {
        if (valoareIntrodusa && nrValues > 0)
        {
            this->nrValues = nrValues;
            if (this->valoareIntrodusa)
            {
                delete[]this->valoareIntrodusa;
            }
            this->valoareIntrodusa = new string[this->nrValues];
            for (int i = 0; i < this->nrValues; i++)
            {
                this->valoareIntrodusa[i] = valoareIntrodusa[i];
            }

        }
    }

    void VerifyInsert(char* c) {
        char* words;
        words = new char[strlen(c) + 1000];
        strcpy(words, words + 11);
        string s(words, words + 11);
        if (isspace(words[11]))
        {
            int i = 12;
            while (!isspace(words[i]))
                i++;
            string nume_tabela(words + 12, words + 1);
            if (this->tableName)
            {
                delete[]this->tableName;
            }
            this->tableName = new char[nume_tabela.length() + 1];
            strcpy(this->tableName, nume_tabela.c_str());
            if (i != 12)
            {
                int m = i + 1;
                while (words[m] != '(' && words[m])
                {
                    m++;
                }
                if (words[strlen(words) - 1] == ';') {
                    string valori(words + i + 1, words + m);
                    char delm[] = ",";
                    if (valori == "VALUES" || valori == "VALUES")
                    {
                        char* stringParenthesis;
                        stringParenthesis = new char[strlen(words) + 1];//va retine ce este intre paranteze la final
                        strcpy(stringParenthesis, words + m);

                        if (stringParenthesis[0] == '(' && stringParenthesis[strlen(stringParenthesis) - 2] == ')')
                        {
                            strcpy(stringParenthesis, stringParenthesis + 1);
                            strrev(stringParenthesis);
                            strcpy(stringParenthesis, stringParenthesis + 2);
                            strrev(stringParenthesis);
                            int nrCommas = 0;
                            for (int i = 0; i < strlen(stringParenthesis); i++)
                            {
                                if (stringParenthesis[i] == ',')nrCommas++;
                            }
                            //se sterg spatiile dintre cuvintele din paranteze pt a verifica corectitudinea pozitiilor virgulelor

                            int k = 0;
                            while (k < strlen(stringParenthesis)) {
                                if (stringParenthesis[k] == ' ') {
                                    int p = k;
                                    while (p < strlen(stringParenthesis) - 1)
                                    {
                                        stringParenthesis[p] = stringParenthesis[p + 1];
                                        p++;
                                    }
                                    k--;
                                }
                                else k++;
                            }
                            //extragerea wordslor
                            if (stringParenthesis[0] != ',') {
                                cout << stringParenthesis << endl;

                                this->valoareIntrodusa = new string[100];
                                char* key = strtok(stringParenthesis, ",");
                                this->nrValues = 0;
                                while (key != NULL)
                                {
                                    this->valoareIntrodusa[this->nrValues] = key;
                                    key = strtok(NULL, ",");
                                    this->nrValues++;
                                }
                                //verificarea corectitudinii dintre nr valorilor si nr virgulelor
                                if (this->nrValues == nrCommas + 1)
                                {
                                    
                                    isCorrect = true;
                                }
                            }

                        }
                    }
                }
            }
            if (isCorrect == false)
                throw mesajExceptie("Comanda introdusa nu este corecta");

            else
                cout << "Comanda introdusa a fost executata" << endl;

        }
    }
    friend ostream& operator<<(ostream&, Insert);
};
ostream& operator<< (ostream& out, Insert i) {
    out << "Comanda introdusa este:" << i.getIsCorrect() << endl;
    out << "Modificarile sunt facute pentru tabela " << i.gettableName() << endl;
    out << "Valorile introduse sunt : ";
    for (int j = 0; j < i.nrValues; j++) {
        out << i.getValoareIntrodusa()[j] << " ";
    }
    out << endl;
    return out;
}

class Column {
    string name;
    string dataType;
    string valoareImplicita;
    int columnLenght;
public:
    Column() {

        this->name = "Default";
        this->dataType = "Default";
        this->valoareImplicita = "Default";
        this->columnLenght = 0;
    }
    Column(string name, string dataType, string valoareImplicita, int columnLenght) {
        this->name = name;
        this->dataType = dataType;
        this->valoareImplicita = valoareImplicita;
        this->columnLenght = columnLenght;

    }
    Column(const Column& c) {
        this->name = c.name;
        this->dataType = c.dataType;
        this->valoareImplicita = c.valoareImplicita;
        this->columnLenght = c.columnLenght;
    }
    Column& operator=(const Column& c) {

        this->name = c.name;
        this->dataType = c.dataType;
        this->valoareImplicita = c.valoareImplicita;
        this->columnLenght = c.columnLenght;
        return *this;

    }
    ~Column() {


    }
    string getname() {
        return this->name;
    }
    string getDataType() {
        return this->dataType;
    }
    string getValoareImplicita() {
        return this->valoareImplicita;
    }
    int getcolumnLenght() {
        return this->columnLenght;
    }

    void setname(string name) {
        this->name = name;
    }
    void setDataType(string dataTyoe) {
        this->dataType = dataType;
    }
    void setValoareImplicta(string valoareImplicita) {
        this->valoareImplicita = valoareImplicita;
    }
    void setcolumnLenght(int columnLenght) {
        this->columnLenght = columnLenght;
    }

    friend ostream& operator<<(ostream&, Column);
};
ostream& operator<<(ostream& out, Column c) {
    out << " A fost apelata coloana " << c.getname();
    out << "cu tipul de data" << c.getDataType();
    out << ", cu valoarea implicita" << c.getValoareImplicita();
    out << " si cu dimensiunea " << c.getcolumnLenght();
    return out;
}
class Table {
    string nume;
   Column* columns;
public:
    Table() {
        nume = "Default";
        columns = nullptr;
    }
    Table(string nume,Column* columns) {
        this->nume = nume;
        if (columns != nullptr) {
            for (int i = 0; sizeof(columns); i++)
                this->columns[i] = columns[i];
        }
    }
    Table(const Table& t) {
        this->nume = t.nume;
        if (this->columns != NULL) {
            delete[] this->columns;

        }
        this->columns = new Column[sizeof(t.columns)];
        for (int i = 0; i < sizeof(t.columns); i++) {

            this->columns[i] = t.columns[i];
        }
    }
    Table& operator=(const Table& t) {
        this->nume = t.nume;
        if (this->columns != NULL) {
            delete[] this->columns;

        }
        this->columns = new Column[sizeof(t.columns)];
        for (int i = 0; i < sizeof(t.columns); i++) {

            this->columns[i] = t.columns[i];
        }
        return *this;
    }
    ~Table() {
        if (this->columns != NULL) {
            delete[] columns;
        }

    }
    string getNume() {
        return this->nume;
    }
   Column* getcolumns() {
        return this->columns;
    }
    void setNume() {
        this->nume = nume;
    }

};


class VerificareComanda {
    char* comanda;
public:
    VerificareComanda() {
        comanda = new char[strlen("Default") + 1];
        strcpy(comanda, "Default");
    }
    VerificareComanda(const char* comanda) {
        this->comanda = new char[strlen(comanda) + 1];
        strcpy(this->comanda, comanda);
    }
    ~VerificareComanda() {
        if (this->comanda != NULL) {
            delete[] this->comanda;
        }
    }
    VerificareComanda& operator=(const VerificareComanda& v) {
        if (this->comanda != NULL) {
            delete[] this->comanda;
        }
        this->comanda = v.comanda;
        this->comanda = new char[strlen(v.comanda) + 1];
        strcpy(this->comanda, v.comanda);
        return *this;
    }
    VerificareComanda(const VerificareComanda& v)
    {
        if (this->comanda != NULL) {
            delete[] this->comanda;
        }
        this->comanda = v.comanda;
        this->comanda = new char[strlen(v.comanda) + 1];
        strcpy(this->comanda, v.comanda);
    }
    char* getComanda() {
        return this->comanda;
    }
    void setComanda(const char* comanda) {
        if (this->comanda != NULL) {
            delete[] this->comanda;
        }
        this->comanda = new char[strlen(comanda) + 1];
        strcpy(this->comanda, comanda);
    }
    void verificaComanda() {
        char* copie;
        copie = new char[strlen(comanda)];
        strcpy(copie, this->comanda);
        char* token = strtok(copie, " ");
        if (token != NULL) {
            if (strcmp(token, "INSERT") == 0) {
                Insert insert;
                insert.VerifyInsert(copie);
            }
            else if (strcmp(token, "DELETE") == 0) {
                Delete del;
                del.verifyDelete(copie);

            }
            else if (strcmp(token, "SELECT") == 0) {
                Select select;
                select.verifySelect(copie);
            }
            else if (strcmp(token, "UPDATE") == 0) {
                Update update;
                update.verifyUpdate(copie);
            }
            else if (strcmp(token, "DISPLAY") == 0) {
                Display display;
                display.verifyDisplay(copie);
            }
            else if (strcmp(token, "DROP") == 0) {
                Drop drop;
                drop.verifyDrop(copie);
            }
            else if (strcmp(token, "CREATE") == 0) {
                Creare create;
                create.verifyCreateTable(copie);
            }
            else {
                throw mesajExceptie("Comanda intrdusa nu poate fi selectata");
            }
        }

    }
    friend istream& operator>> (istream&, VerificareComanda&);
    friend ostream& operator<<(ostream&, VerificareComanda);
};
istream& operator>> (istream& in, VerificareComanda& v) {
    cout << "Introduceti comanda dorita:";
    in >> v.comanda;
    return in;
}
ostream& operator<< (ostream& out, VerificareComanda v) {

    out << "A fost introdusa comanda:" << v.getComanda();
    return out;
}

class Database {
        int nrTables;
        const string host;
        Table* table;
        string name;

    public:
        Database() : host("Project") {
            this->nrTables = 0;
            this->table = NULL;
            this->name = "";
        }

        Database(int nrTables, string host, Table* table, string name) :host(host)
        {
            this->nrTables = nrTables;
            this->table = new Table[this->nrTables];
            for (int i = 0; i < this->nrTables; i++) {
                this->table[i] = table[i];
            }
        }

        Database(const Database& d) : host(d.host) {
            this->table = new Table[d.nrTables];
            for (int i = 0; i < d.nrTables; i++)
            {
                this->table[i] = d.table[i];
            }
            this->name = d.name;
        }
        ~Database() {
            if (this->table) {
                delete[]this->table;
            }
        }
        Database& operator=(const Database& d) {
            if (this->name != d.name) {
                this->name = d.name;
                if (this->table) {
                    delete[]this->table;
                }
                this->table = new Table[d.nrTables];
                for (int i = 0; i < d.nrTables; i++) {
                    this->table[i] = d.table[i];
                }
                return*this;
            }
        }

        //get si set
        string getHost() {
            return this->host;
        }
        string getName() {
            return this->name;
        }
        void setName(string name) {
            if (name.length() > 0) {
                this->name = name;
            }
        }
        Table* getTable() {
            return this->table;
        }
        Table getTable(int index) {
            if (index >= 0 && index < nrTables) {
                return this->table[index];
            }
        }
        void setTable(Table* table, int nrTables) {
            if (table && nrTables > 0) {
                this->nrTables = nrTables;
                if (this->table) {
                    delete[]this->table;
                }
                this->table = new Table[this->nrTables];
                for (int i = 0; i < this->nrTables; i++) {
                    this->table[i] = table[i];
                }
            }
        }
        int getNrTables() {
            return this->nrTables;
        }

    };




void main() {

    char in[300];

    try {
        VerificareComanda verificare;
        cout << "Introduceti o comanda: " << endl;
        cin.getline(in, 255);
        verificare.setComanda(in);
        verificare.verificaComanda();
    }
    catch (mesajExceptie exceptie) {
        cout << exceptie.getMesajDeExceptie();
    }
    cout << endl;
    cout << "Serverul bazei de date este: ";
    Database db;
    cout << db.getHost();


}
